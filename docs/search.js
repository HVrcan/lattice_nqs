window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "src", "modulename": "src", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.dynamics", "modulename": "src.dynamics", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution", "modulename": "src.dynamics", "qualname": "evolution", "kind": "class", "doc": "<p>Initializes and runs the dynamics of the given Heisenberg model represented with an RBM.\\\nContains the methods for calculating all the correlation functions.</p>\n\n<h1 id=\"variables\">Variables</h1>\n\n<ul>\n<li><code>lattice</code>: details about the spin lattice</li>\n<li><code>initial</code>: starting network parameter array</li>\n<li><code>steps</code>: how many steps in the dynamics</li>\n<li><code>end_time</code>: time interval for the dynamics</li>\n</ul>\n\n<h2 id=\"kwargs\">Kwargs</h2>\n\n<ul>\n<li><code>tinv</code>: is the network translationally invariant? this changes the number of used parameters</li>\n<li><code>perturbator</code>: a time-dependent function to calculate the perturbation strength</li>\n<li><code>integrator</code>: update calculation algorithm - choice between <code>'heun'</code>, <code>'implicit_midpoint'</code></li>\n<li><code>formulation</code>: decide between different ways to calculate derivatives: <code>'regularization'</code>, <code>'diagonalization'</code>, <code>'geometric'</code></li>\n<li><code>afm_sector</code>: bool; decides if you keep only the zero-magnetization sector of the Hiblert space</li>\n<li><code>model</code>: ground state model, choose between: <code>'heisenberg'</code>, <code>'ising'</code></li>\n<li><code>gauge</code>: apply gauge transformation?</li>\n<li><code>noise_level</code>: controls how much artificial noise you introduce into the energy gradient</li>\n<li><code>scale</code>: multiply the wave fucntion with this number</li>\n</ul>\n\n<h1 id=\"properties\">Properties</h1>\n\n<ul>\n<li><code>sampler</code>: everything regarding the full sampling</li>\n<li><code>states</code>: list of network parameter states</li>\n<li><code>energies</code>: list of loss (variational) energy values</li>\n<li><code>correlations</code>: dictionary of correlation functions, keyed by <code>(i,j)</code> tuples of lattice indices</li>\n</ul>\n\n<h1 id=\"methods\">Methods</h1>\n\n<ul>\n<li><code>derivative</code>: calculates the derivative in the TDVP EoM</li>\n<li><code>integrate</code>: predicts the next step in the dynamics</li>\n<li><code>run</code>: evolves the system in time, given the settings of the object</li>\n<li><code>process_links (links)</code>: calculates the time dependence curve for the (z)correlation function(s) at the given <code>links</code> list, \\\nfor every state in <code>states</code></li>\n<li><code>process_spectrum</code>: calculates the spectrum of the S-matrix for every state in <code>states</code></li>\n</ul>\n"}, {"fullname": "src.dynamics.evolution.__init__", "modulename": "src.dynamics", "qualname": "evolution.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lattice</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">hilbert</span><span class=\"o\">.</span><span class=\"n\">lattice</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span>,</span><span class=\"param\">\t<span class=\"n\">initial</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end_time</span>,</span><span class=\"param\">\t<span class=\"n\">tinv</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">normal_sampling</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">perturbator</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">evolution</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">taming</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">integrator</span><span class=\"o\">=</span><span class=\"s1\">&#39;heun&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">formulation</span><span class=\"o\">=</span><span class=\"s1\">&#39;geometric&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">afm_sector</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;heisenberg&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">gauge</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">noise_level</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">regulator</span><span class=\"o\">=</span><span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">lagrange_norm</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "src.dynamics.evolution.steps", "modulename": "src.dynamics", "qualname": "evolution.steps", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.dt", "modulename": "src.dynamics", "qualname": "evolution.dt", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.sampler", "modulename": "src.dynamics", "qualname": "evolution.sampler", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.perturbator", "modulename": "src.dynamics", "qualname": "evolution.perturbator", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.times", "modulename": "src.dynamics", "qualname": "evolution.times", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.states", "modulename": "src.dynamics", "qualname": "evolution.states", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.energies", "modulename": "src.dynamics", "qualname": "evolution.energies", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.psis", "modulename": "src.dynamics", "qualname": "evolution.psis", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.residuals", "modulename": "src.dynamics", "qualname": "evolution.residuals", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.metric_velocity", "modulename": "src.dynamics", "qualname": "evolution.metric_velocity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.gradient_velocity", "modulename": "src.dynamics", "qualname": "evolution.gradient_velocity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.arc", "modulename": "src.dynamics", "qualname": "evolution.arc", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.path", "modulename": "src.dynamics", "qualname": "evolution.path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.regulator", "modulename": "src.dynamics", "qualname": "evolution.regulator", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.dynamics.evolution.derivative", "modulename": "src.dynamics", "qualname": "evolution.derivative", "kind": "function", "doc": "<p>Calculates the derivative using either the standard TDVP formulation or the geometric method.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.integrate", "modulename": "src.dynamics", "qualname": "evolution.integrate", "kind": "function", "doc": "<p>Predicts the parameter vector in the next step of the time integration, from the initial <code>state</code>, using the selected integrator.\\\nIntegrator choices:</p>\n\n<ul>\n<li><code>\"heun\"</code>: 2nd order explicit (RK2)</li>\n<li><code>\"implicit_midpoint\"</code>: Newton-Rhapson implicit method, solution obtained by the <code>sp.optimize.newton</code> root finder</li>\n</ul>\n\n<p>NOTE: taming is governed by the class property and affects the calculation of derivatives</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">state</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.run", "modulename": "src.dynamics", "qualname": "evolution.run", "kind": "function", "doc": "<p>Evolve the system in time using the TDVP EoM.</p>\n\n<p>Steps:</p>\n\n<ol>\n<li>Perturb the Hamiltonian.</li>\n<li>Calculate the next parameter preiction.</li>\n<li>Pile up the states and the time-dependent observables (energy)</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.process_links", "modulename": "src.dynamics", "qualname": "evolution.process_links", "kind": "function", "doc": "<p>Calculates the correlation functions at each state of the process.\\\nCorrelatoins are written in a <code>link -&gt; list</code> dictionary, where the <code>list</code> is all the values of the correlation at the lattice <code>link</code> during the process.</p>\n\n<ul>\n<li><code>links</code>: an array of tuples representing links on the lattice where the calculation is performed</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">links</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.process_spectrum", "modulename": "src.dynamics", "qualname": "evolution.process_spectrum", "kind": "function", "doc": "<p>Calculates the time dependence of the S-matrix spectrum.</p>\n\n<p>Returns a matrix where each row corresponds to one eigenvalue dynamics.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.read_parameters", "modulename": "src.dynamics", "qualname": "evolution.read_parameters", "kind": "function", "doc": "<p>Takes a time series of network parameters in <code>inputs</code> and analizes them with the NQS machinery.\\\nAssumes that the first state (index <code>0</code>) is the first states in the dynamics. Ground state is sent in the object initialization.</p>\n\n<ul>\n<li><code>links</code>: list of links to proccess</li>\n</ul>\n\n<p>Does not reset the calculation - use only on an object without pre-existing data.\\\nFormat inputs as a list of (or an array) of <code>numpy</code> arrays: <code>[parameters0, parameters1, ...]</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">inputs</span>, </span><span class=\"param\"><span class=\"n\">links</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.infidelity", "modulename": "src.dynamics", "qualname": "evolution.infidelity", "kind": "function", "doc": "<p>This must be the millionth time I define this function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">v1</span>, </span><span class=\"param\"><span class=\"n\">v2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.wavefunction_infidelity", "modulename": "src.dynamics", "qualname": "evolution.wavefunction_infidelity", "kind": "function", "doc": "<p>It's the same as infidelity, except that one of the wave functions is calculated from the given <strong>parameters</strong> of the network.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">known_psi</span>, </span><span class=\"param\"><span class=\"n\">network_params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.compute_gradient", "modulename": "src.dynamics", "qualname": "evolution.compute_gradient", "kind": "function", "doc": "<p>Numerically computes the gradient of the function with respect to the given parameters.\nEpsilon is the offset in all directions. Takes into account the generally complex parameters\nand functions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loss_func</span>, </span><span class=\"param\"><span class=\"n\">params</span>, </span><span class=\"param\"><span class=\"n\">epsilon</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.analytical_infidelity_gradient", "modulename": "src.dynamics", "qualname": "evolution.analytical_infidelity_gradient", "kind": "function", "doc": "<p>An attempt of calculating the gradient of infidelity analytically.</p>\n\n<p><strong>NB</strong>: assumes that the reference function (from ED) is normalized</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parameters</span>, </span><span class=\"param\"><span class=\"n\">reference_wf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.gradient_descent_with_convergence", "modulename": "src.dynamics", "qualname": "evolution.gradient_descent_with_convergence", "kind": "function", "doc": "<p>Performs a gradient descent algorithm with convergence criterion for stoping.</p>\n\n<h2 id=\"variables\">Variables</h2>\n\n<ul>\n<li><code>ref_state</code>: state you want to fit your wavefunction to</li>\n<li><code>initial_params</code>: starting parameter array</li>\n</ul>\n\n<h2 id=\"kwargs\">Kwargs</h2>\n\n<ul>\n<li><code>learning_rate</code>: default is 0.01</li>\n<li><code>threshold</code>: convergence criterion for the descent, default is 1e-6 (loss function)</li>\n<li><code>miniter</code>, <code>maxiter</code>: hard limitations for iterations</li>\n<li><code>learning_rate_decay</code>: if supplied, scales down the learning rate every iteration, default values 1 means no scaling</li>\n<li><code>artificial_noise</code>: add Gaussian noise with this much intensity into the gradient</li>\n<li><code>distance_target</code>: measure the straight-line distance towards this target, by default <code>None</code> so it doesn't measure it</li>\n</ul>\n\n<p>Returns the evolution of parameters, the loss function, the psi norm, metric velocities, travelled arc, residual distances, and optionally straight-line distances to the provided target.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ref_state</span>,</span><span class=\"param\">\t<span class=\"n\">initial_params</span>,</span><span class=\"param\">\t<span class=\"n\">learning_rate</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span>,</span><span class=\"param\">\t<span class=\"n\">miniter</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">maxiter</span><span class=\"o\">=</span><span class=\"mi\">1000</span>,</span><span class=\"param\">\t<span class=\"n\">learning_rate_decay</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">artificial_noise</span><span class=\"o\">=</span><span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.fit_network", "modulename": "src.dynamics", "qualname": "evolution.fit_network", "kind": "function", "doc": "<p>Calculates the neural network parameters that describe the Hilbert space state.\nWorks by fitting the parameters with a gradient descent, using infidelity as loss.\nUse only if the object has no data written.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li><code>state</code> is the Hilbert space state that you're fitting to,</li>\n<li><code>initial_guess</code> is random if you don't supply it (default None),</li>\n<li><code>eta</code> is the learning rate (default 0.01),</li>\n<li><code>epsilon</code> is the precision requirement (default 1e-16),</li>\n<li><code>maxit</code> is the maximum number of iterations (default 10000).</li>\n</ul>\n\n<p>Returns the final parameter state, the final loss, and the number of iterations reached.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">state</span>,</span><span class=\"param\">\t<span class=\"n\">initial_guess</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">eta</span><span class=\"o\">=</span><span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">epsilon</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span>,</span><span class=\"param\">\t<span class=\"n\">maxit</span><span class=\"o\">=</span><span class=\"mi\">10000</span>,</span><span class=\"param\">\t<span class=\"n\">add_noise</span><span class=\"o\">=</span><span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">speak</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.dynamics.evolution.fit_dynamics", "modulename": "src.dynamics", "qualname": "evolution.fit_dynamics", "kind": "function", "doc": "<p>Fits the entire series of wave functions (presumably from ED) describing dynamics by calling the <code>fit_network</code> functin for each of them.\\\nThe series is given in the <code>states</code>.</p>\n\n<ul>\n<li><code>start_from_last</code>: decide whether to start from the last state in the fit</li>\n<li><code>postprocess</code>: decide if you want to analyse correlations and spectra</li>\n</ul>\n\n<p>The fit is performed by gradient descent, using infidelity as loss function.</p>\n\n<p>Returns two arrays: <code>losses</code> containing final infidelities, and <code>convergence_steps</code> containing steps it took to fit at that time.</p>\n\n<p><strong>NB</strong>: be mindful of whether you pass ground states or not. The first state of this class is passed in the <code>initial</code> argument.\nIt is assumed that the first state in <code>states</code> is the ground state. Fitting this to the network will overwrite the first state in <code>self.states</code>.</p>\n\n<h2 id=\"kwargs\">Kwargs</h2>\n\n<ul>\n<li><code>noise</code>: strength of the artificial gaussian noise you add into the infidelity gradient</li>\n<li><code>criterion</code>: convergence criterion, default <code>1e-9</code> infidelity</li>\n<li><code>link</code>: which links to process</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">states</span>,</span><span class=\"param\">\t<span class=\"n\">start_from_last</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">noise</span><span class=\"o\">=</span><span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">criterion</span><span class=\"o\">=</span><span class=\"mf\">1e-09</span>,</span><span class=\"param\">\t<span class=\"n\">postprocess</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">links</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact", "modulename": "src.exact", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED", "modulename": "src.exact", "qualname": "ED", "kind": "class", "doc": "<p>Contains the exact diagonalization dynamics of a spin system obtained using quantum-mechanical definitions.</p>\n\n<h2 id=\"variables\">Variables</h2>\n\n<ul>\n<li><code>lattice</code>: a hilbert.lattice-class object to specify the lattice details</li>\n<li><code>steps</code>: how many steps in the dynamics</li>\n<li><code>end_time</code>: time interval for the dynamics</li>\n<li><code>model</code>: which Hamiltonian to use? choose: <code>'heisenberg'</code>, <code>'ising'</code></li>\n<li><code>driving</code>: which model should you use for the driving? choose: <code>'light'</code>, <code>'J1J2'</code>, <code>'JQ'</code></li>\n<li><code>perturbator</code>: a time-dependent function to calculate the perturbation strength</li>\n</ul>\n\n<h2 id=\"properties\">Properties</h2>\n\n<ul>\n<li><code>dt</code>: time step</li>\n<li><code>states</code>: list of states, in time</li>\n<li><code>observables</code>: a dictionary containing the dynamics of all observables defined in the Hilbert space \\\n(access the correlation functions the same way you would access them in <code>hilbert.space</code> class)</li>\n</ul>\n\n<h2 id=\"methods\">Methods</h2>\n\n<ul>\n<li><code>gather_energy(state)</code>, <code>gather_correlations(link, state)</code>: they calculate those observables in a certain quantum state</li>\n<li><code>run()</code>: runs the dynamics</li>\n<li><code>process()</code>: calculates all the observables from all the states of the dynamics</li>\n</ul>\n"}, {"fullname": "src.exact.ED.__init__", "modulename": "src.exact", "qualname": "ED.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lattice</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">hilbert</span><span class=\"o\">.</span><span class=\"n\">lattice</span>,</span><span class=\"param\">\t<span class=\"n\">steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">end_time</span>,</span><span class=\"param\">\t<span class=\"n\">perturbator</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">ED</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">initial</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">start</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;heisenberg&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">driving</span><span class=\"o\">=</span><span class=\"s1\">&#39;light&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">gauging</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">afm</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">tacit</span><span class=\"o\">=</span><span class=\"kc\">True</span></span>)</span>"}, {"fullname": "src.exact.ED.lattice", "modulename": "src.exact", "qualname": "ED.lattice", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED.steps", "modulename": "src.exact", "qualname": "ED.steps", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED.dt", "modulename": "src.exact", "qualname": "ED.dt", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED.perturbator", "modulename": "src.exact", "qualname": "ED.perturbator", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED.init", "modulename": "src.exact", "qualname": "ED.init", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED.states", "modulename": "src.exact", "qualname": "ED.states", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED.times", "modulename": "src.exact", "qualname": "ED.times", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED.tacit", "modulename": "src.exact", "qualname": "ED.tacit", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.exact.ED.gather_energy", "modulename": "src.exact", "qualname": "ED.gather_energy", "kind": "function", "doc": "<p>Calculate the energy in a given <code>state</code> vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.gather_correlation", "modulename": "src.exact", "qualname": "ED.gather_correlation", "kind": "function", "doc": "<p>Calculate the expectation values of correlation function(s) at the given <code>link</code> , in a given <code>state</code> vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">link</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.gather_sitespins", "modulename": "src.exact", "qualname": "ED.gather_sitespins", "kind": "function", "doc": "<p>Calculates the values of all the spin functions at individual sites.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">site</span>, </span><span class=\"param\"><span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.gather_neel", "modulename": "src.exact", "qualname": "ED.gather_neel", "kind": "function", "doc": "<p>Calculates all the Neel vector elements on a <code>bond</code>.\\\nNOTE: Makes sense only when the full Hilbert space is sampled.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">bond</span>, </span><span class=\"param\"><span class=\"n\">state</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.gather_plusminus", "modulename": "src.exact", "qualname": "ED.gather_plusminus", "kind": "function", "doc": "<p>Calculates the values of the N+- vector on the bond.\\\nRefer to Lukas' notes for clarification.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">i</span>, </span><span class=\"param\"><span class=\"n\">j</span>, </span><span class=\"param\"><span class=\"n\">state</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.make_correlation", "modulename": "src.exact", "qualname": "ED.make_correlation", "kind": "function", "doc": "<p>Calculates the correlation of a certain <code>link</code>. If it doesn't exist as a Hilbert space matrix, makes the matrix.</p>\n\n<p>Correlation return type is added to the <code>link</code>-><code>value</code> dictionary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">link</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.process", "modulename": "src.exact", "qualname": "ED.process", "kind": "function", "doc": "<p>Full calculation of observables from states gathered throught the dynamics.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">extra_links</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.asses_weights", "modulename": "src.exact", "qualname": "ED.asses_weights", "kind": "function", "doc": "<p>Calculates the weights of a neural network analytically from ED results.\\\nMakes sense only for a Restricted Boltzmann Machine with a single hidden node.\\\nNB: here, the biases are explicitly set to zero here. This could be justified by requesting pairity invariance.</p>\n\n<p>Returns a time series of network parameters formated as <code>[weights]</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.read_wavefunctions", "modulename": "src.exact", "qualname": "ED.read_wavefunctions", "kind": "function", "doc": "<p>Takes a time series of wave functions written in <code>inputs</code> and analyses them as if they were generated by the class.\\\nAssumes that the first state (index <code>0</code>) is the ground state.</p>\n\n<p>Does not reset the calculation - use only on an object without pre-existing data.\\\nFormat inputs as a list (or an array) of <code>numpy</code> arrays: <code>[psi0, psi1, ...]</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">inputs</span>, </span><span class=\"param\"><span class=\"n\">extra_links</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.exact.ED.run", "modulename": "src.exact", "qualname": "ED.run", "kind": "function", "doc": "<p>Runs the dynamics given the settings of the object.</p>\n\n<p>Steps:</p>\n\n<ol>\n<li>diagonalize the unperturbed Hamiltonian to get the ground state,</li>\n<li>perturb the Hamiltonian (perturbation is, in general, time-dependent),</li>\n<li>diagonalize at every time step,</li>\n<li>calculate the full state at every time, with the ground state as a primer.</li>\n</ol>\n\n<p><code>postprocess</code>: decide if you want to calculate observables immediately after the run.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">postprocess</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">extra_links</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full", "modulename": "src.full", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.full.add_noise", "modulename": "src.full", "qualname": "add_noise", "kind": "function", "doc": "<p>Adds a noise factor to the vector. The noise added to each component <code>fi</code> is a complex number drawn from a normal distribution with:\\\n<code>variance = |eta*fi|^2</code>.</p>\n\n<ul>\n<li><code>eta</code>: noise strength factor (typically small).</li>\n</ul>\n\n<p>Returns the noisified vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">eta</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler", "modulename": "src.full", "qualname": "sampler", "kind": "class", "doc": "<p>Handles the calculation of averages and variational manifold elements for the case of full sampling of the Hilbert space by RBM.</p>\n\n<h2 id=\"variables\">Variables</h2>\n\n<ul>\n<li><code>hspace</code>: the Hilbert space object</li>\n<li><code>alpha</code>: network density</li>\n<li><code>tinvariant</code>: is the network translationally invariant? this changes the number of used parameters</li>\n<li><code>normal</code>: use normal full averaging? (as opposed to Monte-Carlo-like)</li>\n<li><code>scale</code>: multiply the wave function with this number</li>\n<li><code>real</code>: are the parameters real?</li>\n<li><code>noise_level</code>: controls how much artificial noise you introduce into the energy gradient</li>\n</ul>\n\n<h2 id=\"properties\">Properties</h2>\n\n<ul>\n<li><code>network</code>: contains rbm elements (see rbm.py)</li>\n<li><code>psiket</code>: ket in the Hilbert (sub)space</li>\n<li><code>S</code>: quantum Fisher matrix</li>\n<li><code>F</code>: energy gradient</li>\n<li><code>Lnorm</code>: gradient of the norm loss</li>\n</ul>\n\n<h2 id=\"methods\">Methods</h2>\n\n<ul>\n<li><code>Evar</code>: average energy</li>\n<li><code>Cvar(link)</code>: average correlation at <code>link</code></li>\n<li><code>Czvar(link)</code>: average z-correlation at <code>link</code></li>\n<li><code>update(parameters)</code>: updates the network with new parameters and reflects the updates to the sampler</li>\n</ul>\n"}, {"fullname": "src.full.sampler.__init__", "modulename": "src.full", "qualname": "sampler.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">hspace</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">hilbert</span><span class=\"o\">.</span><span class=\"n\">space</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span>,</span><span class=\"param\">\t<span class=\"n\">tinvariant</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">normal</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">real</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">noise</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span>)</span>"}, {"fullname": "src.full.sampler.hspace", "modulename": "src.full", "qualname": "sampler.hspace", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.full.sampler.network", "modulename": "src.full", "qualname": "sampler.network", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.full.sampler.noise", "modulename": "src.full", "qualname": "sampler.noise", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.full.sampler.psiket", "modulename": "src.full", "qualname": "sampler.psiket", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.full.sampler.update", "modulename": "src.full", "qualname": "sampler.update", "kind": "function", "doc": "<p>Updates the neural network with the <code>new_parameters</code> array, along with other things in the class.</p>\n\n<p>-<code>just_parameters</code>: do you only want to update the NN parameters and the wave function? if <code>False</code>, you also update S and F.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">new_parameters</span>, </span><span class=\"param\"><span class=\"n\">just_parameters</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.Evar", "modulename": "src.full", "qualname": "sampler.Evar", "kind": "function", "doc": "<p>Variational (average) energy.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.E2var", "modulename": "src.full", "qualname": "sampler.E2var", "kind": "function", "doc": "<p>Square of Hamiltonian observable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.Cvar", "modulename": "src.full", "qualname": "sampler.Cvar", "kind": "function", "doc": "<p>Average correlation at <code>link</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">link</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.Czvar", "modulename": "src.full", "qualname": "sampler.Czvar", "kind": "function", "doc": "<p>Average z correlation at <code>link</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">link</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.sptectrumS", "modulename": "src.full", "qualname": "sampler.sptectrumS", "kind": "function", "doc": "<p>Calculates and sorts the eigenvalue spectrum of the S-matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.residual", "modulename": "src.full", "qualname": "sampler.residual", "kind": "function", "doc": "<p>Calculates the residual distance.</p>\n\n<ul>\n<li><code>w</code>: current parameters</li>\n<li><code>wdot</code>: derivative of the parameter vector</li>\n</ul>\n\n<p>Careful with indices - this thing is calculared from the update directly, so it will always have one less values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">wdot</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.metric_velocity", "modulename": "src.full", "qualname": "sampler.metric_velocity", "kind": "function", "doc": "<p>Calculates the metric veolcity, or the integrand in the manifold arc distance along a trajectory.\\\nAssumes that the S matrix is Hermitian and positive-definite.</p>\n\n<ul>\n<li><code>w</code>: current parameters</li>\n<li><code>wdot</code>: derivative of the parameter vector</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">wdot</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.gradient_velocity_it", "modulename": "src.full", "qualname": "sampler.gradient_velocity_it", "kind": "function", "doc": "<p>Calculates the metric veolcity, or the integrand in the manifold arc distance along a trajectory.\\\nDoesn't use the S matrix, but rather a substitute of the EoM into the distance integral formula.</p>\n\n<ul>\n<li><code>it</code> denotes imaginary time, therefore don't call this funciton in dynamics</li>\n</ul>\n\n<hr />\n\n<ul>\n<li><code>w</code>: current parameters</li>\n<li><code>wdot</code>: derivative of the parameter vector</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">wdot</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.gradient_velocity_rt", "modulename": "src.full", "qualname": "sampler.gradient_velocity_rt", "kind": "function", "doc": "<p>Calculates the metric veolcity, or the integrand in the manifold arc distance along a trajectory.\\\nDoesn't use the S matrix, but rather a substitute of the EoM into the distance integral formula.</p>\n\n<ul>\n<li><code>rt</code> denotes real time, therefore don't call this function in optimization</li>\n</ul>\n\n<hr />\n\n<ul>\n<li><code>w</code>: current parameters</li>\n<li><code>wdot</code>: derivative of the parameter vector</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">wdot</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.full.sampler.line_distance", "modulename": "src.full", "qualname": "sampler.line_distance", "kind": "function", "doc": "<p>Measures the distance from point <code>w</code> to point <code>target_w</code> on the manifold along a straigh line trajectory. Still takes into account the S-matrix as metric.</p>\n\n<ul>\n<li><code>division</code>: discretization of the line between the two points</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">target_w</span>, </span><span class=\"param\"><span class=\"n\">division</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate", "modulename": "src.groundstate", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.get_normalized_weights", "modulename": "src.groundstate", "qualname": "get_normalized_weights", "kind": "function", "doc": "<p>Calculates the weights of the wave function <code>psi</code> when it's normalized.\\\nWorks only for the RBM architecture with <code>alpha=1/4</code> and <code>N=4</code>.</p>\n\n<p>Returns the weights.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">psi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.splice", "modulename": "src.groundstate", "qualname": "splice", "kind": "function", "doc": "<p>Separates a complex-valued vector <code>w</code> into a double-dimensional real-valued vector.</p>\n\n<ul>\n<li><code>w</code> -> [<code>Re(w)</code>, <code>Im(w)</code>]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">w</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.patch", "modulename": "src.groundstate", "qualname": "patch", "kind": "function", "doc": "<p>Rebuilds the complex vector that has been separated into a form given by the function <code>splice</code>.</p>\n\n<ul>\n<li><code>w</code> -> <code>w[:len/2] + 1j*w[len/2:]</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">w</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent", "modulename": "src.groundstate", "qualname": "descent", "kind": "class", "doc": "<p>A gradient descent into the ground state of the lattice Heisenberg model.</p>\n\n<h1 id=\"variables\">Variables</h1>\n\n<ul>\n<li><code>lattice</code>: details about the spin lattice</li>\n<li><code>alpha</code>: network density</li>\n<li><code>eta</code>: learning rate</li>\n<li><code>tinv</code>: is the network translationally invariant? this changes the number of used parameters</li>\n<li><code>afm_sector</code>: keep only the zero-magnetization sector of the Hiblert space?</li>\n<li><code>scale</code>: multiply the wave function with this number</li>\n<li><code>taming</code>: do you want to rescale the gradient(s)? this helps if they are too huge</li>\n<li><code>real_parameters</code>: initialize parameters as real?</li>\n<li><code>epsilon</code><strong>*</strong>: a function depending on the step that modifies the regularization during training</li>\n<li><code>normalize_initial</code>: how do you want to recalculate weights to normalize the wave fucntion? choose: <code>'analytical'</code>, <code>'numerical'</code>, or leave default <code>None</code>.</li>\n<li><code>penalize_norm</code>: do you want to penalize the norm during training?</li>\n<li><code>Lnorm_importance</code><strong>*</strong>: a function that modifies the learning rate of normalization during training</li>\n<li><code>lagrange</code>: decides whether to use lagrange multipliers to conserve the norm during training. <strong>NB</strong>: setting to <code>True</code> normalizes the initial parameters with <code>'tdvp'</code>, and overwrites <code>refactoring</code> and <code>penalize_norm</code> to <code>False</code>.</li>\n</ul>\n\n<p><strong>*Both of these must be functions. If you don't know what they mean, leave them as defaults.</strong></p>\n\n<h1 id=\"properties\">Properties</h1>\n\n<ul>\n<li><code>sampler</code>: everything regarding the full sampling</li>\n<li><code>states</code>: list of network parameter states</li>\n<li><code>loss</code>: list of loss function values (variational energy)</li>\n<li><code>psis</code>: list of wave function vectors</li>\n<li><code>normF</code>, <code>normSF</code>, <code>normLnorm</code>: list of norms of gradients of F, S^-1F, L_norm respectively</li>\n</ul>\n\n<h1 id=\"methods\">Methods</h1>\n\n<ul>\n<li><code>gradient</code>: calculates gradient with stochastic reconfiguration</li>\n<li><code>optimize</code>: performs the descent</li>\n<li><code>process (links)</code>: calculates the optimization curve for the (z)correlation function(s) at the given <code>links</code> list</li>\n</ul>\n\n<p>Regularizaiton recipe taken from the Carleo &amp; Troyer paper.</p>\n"}, {"fullname": "src.groundstate.descent.__init__", "modulename": "src.groundstate", "qualname": "descent.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lattice</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">hilbert</span><span class=\"o\">.</span><span class=\"n\">lattice</span>,</span><span class=\"param\">\t<span class=\"n\">alpha</span>,</span><span class=\"param\">\t<span class=\"n\">eta</span>,</span><span class=\"param\">\t<span class=\"n\">regularization</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">descent</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">phase</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">tinv</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">normal_sampling</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">geometric</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">afm_sector</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;heisenberg&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">gauge</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">real_parameters</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">refactoring</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">normalize_initial</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">penalize_norm</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">Lnorm_importance</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">descent</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">lagrange</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "src.groundstate.descent.eta", "modulename": "src.groundstate", "qualname": "descent.eta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.sampler", "modulename": "src.groundstate", "qualname": "descent.sampler", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.penalize_norm", "modulename": "src.groundstate", "qualname": "descent.penalize_norm", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.Lnorm_importance", "modulename": "src.groundstate", "qualname": "descent.Lnorm_importance", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.epsilon", "modulename": "src.groundstate", "qualname": "descent.epsilon", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.geo", "modulename": "src.groundstate", "qualname": "descent.geo", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.refactoring", "modulename": "src.groundstate", "qualname": "descent.refactoring", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.states", "modulename": "src.groundstate", "qualname": "descent.states", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.loss", "modulename": "src.groundstate", "qualname": "descent.loss", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.psis", "modulename": "src.groundstate", "qualname": "descent.psis", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.normF", "modulename": "src.groundstate", "qualname": "descent.normF", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.normLnorm", "modulename": "src.groundstate", "qualname": "descent.normLnorm", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.groundstate.descent.geo_gradient", "modulename": "src.groundstate", "qualname": "descent.geo_gradient", "kind": "function", "doc": "<p>Calculates the gradient using the geometric implementation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">s</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.gradient", "modulename": "src.groundstate", "qualname": "descent.gradient", "kind": "function", "doc": "<p>Calculates the analytical gradient of the loss function.\\\nThis is obtained by the 'stochastic reconfiguration method' - check litterature.</p>\n\n<p>UPDATE THIS:\nThe gradient itself is obtained convergently, through the <code>np.linalg.lstsq</code> function (rather than regularization and pseudoinversion).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">s</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.compute_Lnorm", "modulename": "src.groundstate", "qualname": "descent.compute_Lnorm", "kind": "function", "doc": "<p>Loss for norm optimization: <code>L=(1-&lt;psi|psi&gt;)^2.</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.numerical_norm_gradient", "modulename": "src.groundstate", "qualname": "descent.numerical_norm_gradient", "kind": "function", "doc": "<p>Compute the numerical gradient of L_norm with respect to w.\\\nUses the derivative scheme from Wirtinger calculus. See Torch documentation.</p>\n\n<ul>\n<li><code>epsilon</code>: infinitesimal step in parameters</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">epsilon</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.normalise_params", "modulename": "src.groundstate", "qualname": "descent.normalise_params", "kind": "function", "doc": "<p>Attempts to find a set of network parameters which represent a normalised wave function.\\\nThis is done by optimizing the loss <code>L = (1-&lt;psi|psi&gt;)**2</code> with gradient descent.</p>\n\n<ul>\n<li><code>tolerance</code>: controls how precise the convergence should be</li>\n<li><code>maxiters</code>: manual break for the training loop if it goes into too many steps</li>\n</ul>\n\n<p>Fun fact: normaliSe is British, normaliZe is American English</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">learning_rate</span><span class=\"o\">=</span><span class=\"mf\">0.01</span>, </span><span class=\"param\"><span class=\"n\">tolerance</span><span class=\"o\">=</span><span class=\"mf\">1e-08</span>, </span><span class=\"param\"><span class=\"n\">maxiters</span><span class=\"o\">=</span><span class=\"mi\">1000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.refactor_Lnorm", "modulename": "src.groundstate", "qualname": "descent.refactor_Lnorm", "kind": "function", "doc": "<p>Rescales the <code>gradLnorm</code> so that its norm has an upper limit corresponding to the maximum norm of the energy gradient in the whole simulation.\\\nThis means that, if its norm is bigger, then reduce it to that limit, otherwise do nothing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">gradLnorm</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.lagrange_gradient", "modulename": "src.groundstate", "qualname": "descent.lagrange_gradient", "kind": "function", "doc": "<p>Performs an update of parameters that conserves the norm using Lagrange multipler(s).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">s</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.optimize", "modulename": "src.groundstate", "qualname": "descent.optimize", "kind": "function", "doc": "<p>Performs the gradient descent algorithm.</p>\n\n<ul>\n<li><code>precision</code>: convergence criterion for the loss function</li>\n<li><code>miniter</code>: minimum number of iterations</li>\n<li><code>maxiter</code>: maximum number of iterations</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">precision</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span>, </span><span class=\"param\"><span class=\"n\">miniter</span><span class=\"o\">=</span><span class=\"mi\">100</span>, </span><span class=\"param\"><span class=\"n\">maxiter</span><span class=\"o\">=</span><span class=\"mi\">10000</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.process", "modulename": "src.groundstate", "qualname": "descent.process", "kind": "function", "doc": "<p>Calculates the correlation functions at each state of the process.\\\nCorrelatoins are written in a <code>link -&gt; list</code> dictionary, where the <code>list</code> is all the values of the correlation at the lattice <code>link</code> during the process.</p>\n\n<ul>\n<li><code>links</code>: an array of tuples representing links on the lattice where the calculation is performed</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">links</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.groundstate.descent.nudge", "modulename": "src.groundstate", "qualname": "descent.nudge", "kind": "function", "doc": "<p>Corrects the weights of the neural network to be complex, but still have the same energy.\\\nUses a root-finding algorithm to find the state whose energy offset is zero. This is equivalent to supervised learning.</p>\n\n<ol>\n<li>Initialize weights: take the trained weights in <code>states[-1]</code> and multiply them with <code>exp(1j*phase_nudge)</code>.</li>\n<li>Find the root: construct a function <code>L (w) = |E_0 - E(w)|</code>, where <code>E_0</code> is the pre-trained energy, and find the weights <code>w</code> for which this function has a root.</li>\n</ol>\n\n<p>USE only if you have performed the graident descent by the <code>descent()</code> function. Otherwise the results are senseless.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">phase_nudge</span><span class=\"o\">=</span><span class=\"mf\">1.5707963267948966</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert", "modulename": "src.hilbert", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.sigma_x", "modulename": "src.hilbert", "qualname": "sigma_x", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[0, 1],\n       [1, 0]])"}, {"fullname": "src.hilbert.sigma_y", "modulename": "src.hilbert", "qualname": "sigma_y", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[ 0.+0.j, -0.-1.j],\n       [ 0.+1.j,  0.+0.j]])"}, {"fullname": "src.hilbert.sigma_z", "modulename": "src.hilbert", "qualname": "sigma_z", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[ 1,  0],\n       [ 0, -1]])"}, {"fullname": "src.hilbert.eye", "modulename": "src.hilbert", "qualname": "eye", "kind": "variable", "doc": "<p></p>\n", "default_value": "array([[1., 0.],\n       [0., 1.]])"}, {"fullname": "src.hilbert.remove_from_tuple", "modulename": "src.hilbert", "qualname": "remove_from_tuple", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tpl</span>, </span><span class=\"param\"><span class=\"n\">num</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.new_correlation", "modulename": "src.hilbert", "qualname": "new_correlation", "kind": "function", "doc": "<p>Returns a contribution of an operator string of arbitrary length, in the complete product basis.</p>\n\n<ul>\n<li><code>sites</code>: number of particles,</li>\n<li><code>tup</code>: tuple containing all the site indices that contribute to the correlation.</li>\n<li><code>direction</code>: decides in which direction (of the algebra) are the matrices contributing, choose between: <code>'all'</code>, <code>'x'</code>, <code>'y'</code>, <code>'z'</code></li>\n<li><code>gauge</code>: apply the gauge transformation? this changes the signs of non-diagonal elements (effectivelly removing the sign structure)</li>\n</ul>\n\n<p>If you want just one site, send a tuple in the form <code>(index,)</code>.\\\nThis is equal to the correlation funciton matrix at those sites.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sites</span>, </span><span class=\"param\"><span class=\"n\">tup</span>, </span><span class=\"param\"><span class=\"n\">gauge</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.correlation", "modulename": "src.hilbert", "qualname": "correlation", "kind": "function", "doc": "<p>Returns a contribution of an interaction pair of Heisenberg model, in the complete product basis.</p>\n\n<ul>\n<li><code>sites</code>: number of particles,</li>\n<li><code>index1</code>, <code>index2</code>: two indices where from which the contribution is calculated.</li>\n<li><code>zonly</code>: decides whether to return only the z-component of the result</li>\n<li><code>gauge</code>: apply the gauge transformation? this changes the signs of non-diagonal elements (effectivelly removing the sign structure)</li>\n</ul>\n\n<p>This is equal to the correlation funciton matrix at those two sites.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sites</span>, </span><span class=\"param\"><span class=\"n\">index1</span>, </span><span class=\"param\"><span class=\"n\">index2</span>, </span><span class=\"param\"><span class=\"n\">zonly</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">gauge</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.connected_pairs", "modulename": "src.hilbert", "qualname": "connected_pairs", "kind": "function", "doc": "<p>Creates a list of linked nearest-neighbour pairs on a 2D lattice. The sites are indexed as<code>x+Lx*y</code> for lattice coordinates <code>(x,y)</code>.\\\nThe indices are arranged to follow the positive x and y directions. For example, pair <code>(0,1)</code> is positive in x, while <code>(1,0)</code> is not.</p>\n\n<ul>\n<li><code>periodic_x</code>, <code>periodic_y</code>: bools that control the periodicity in x- and y-directions, respectivelly.</li>\n<li><code>along_y</code>: if <code>True</code>, the  returned links will only be along the y-direction.</li>\n</ul>\n\n<p>Returns a list of tuples.</p>\n\n<p>~Created by me and <code>Chat, j'ai p\u00e9t\u00e9  3.5</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Ly</span>, </span><span class=\"param\"><span class=\"n\">periodic_x</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">periodic_y</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">along_y</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.diagonal_pairs", "modulename": "src.hilbert", "qualname": "diagonal_pairs", "kind": "function", "doc": "<p>Creates a list of links between diagonal sites on a 2D lattice.  The sites are indexed as <code>x+Lx*y</code> for lattice coordinates <code>(x,y)</code>. \\</p>\n\n<ul>\n<li><code>periodic_x</code>, <code>periodic_y</code>: bools that control the periodicity in x- and y-directions, respectivelly.</li>\n</ul>\n\n<p>Returns a list of tuples.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Ly</span>, </span><span class=\"param\"><span class=\"n\">periodic_x</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">periodic_y</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.get_square_corners", "modulename": "src.hilbert", "qualname": "get_square_corners", "kind": "function", "doc": "<p>Creates a list of indices of all 2x2 squares on a square lattice.\\\nThe return type is a list of tuples of the format: <code>(bottom_left, bottom_right, top_left, top_right)</code>.</p>\n\n<ul>\n<li><code>periodic_x</code>, <code>periodic_y</code>: bools that control the periodicity in x- and y-directions, respectivelly.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Ly</span>, </span><span class=\"param\"><span class=\"n\">periodic_x</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">periodic_y</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.plaquette_link_pairs", "modulename": "src.hilbert", "qualname": "plaquette_link_pairs", "kind": "function", "doc": "<p>Creates a list of all the pairs of dimer links in a square lattice. The sites are indexed as <code>x+Lx*y</code> for lattice coordinates <code>(x,y)</code>. \\\nA dimer is a link between two sites, in the format of a tuple of site indices.</p>\n\n<ul>\n<li><code>periodic_x</code>, <code>periodic_y</code>: bools that control the periodicity in x- and y-directions, respectivelly.</li>\n</ul>\n\n<p>Returns a list of lists of tuples, where each sub-list contains two tuples, each representing a pair of horizontal or vertical links.\\\n<code>[</code>\\\n#pair_1: <code>[(link1_index1, link1_index_2), (link2_index1, link2_index2)],</code>\\\n#pair_2: <code>[...],</code> \\\n<code>...</code>\\\n<code>]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Ly</span>, </span><span class=\"param\"><span class=\"n\">periodic_x</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">periodic_y</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.lattice", "modulename": "src.hilbert", "qualname": "lattice", "kind": "class", "doc": "<p>Contains all the information about the lattice geometry and connections.\\\nInitialized from the lattice dimensions and periodicity.\\\nSpins are indexed as <code>x+Lx*y</code> for lattice coordinates <code>(x,y)</code>.</p>\n\n<h2 id=\"variables\">Variables</h2>\n\n<ul>\n<li><code>Lx</code>, <code>Ly</code>: dimensions of the lattice</li>\n<li><code>periodic_x</code>, <code>periodic_y</code>: bools denoting periodicity</li>\n</ul>\n\n<h2 id=\"properties\">Properties</h2>\n\n<p>The following are formated as lists of tuples.</p>\n\n<ul>\n<li><code>links</code>: contains index pairs of all the connected sites on the lattice</li>\n<li><code>ylinks</code>: contains index pairs of connections along the y-direction only</li>\n<li><code>diagolinks</code>: contains index pairs of all diagonal connections</li>\n<li><code>dimer_pairs</code>: contains all pairs of links that make two dimers in a lattice plaquette</li>\n</ul>\n"}, {"fullname": "src.hilbert.lattice.__init__", "modulename": "src.hilbert", "qualname": "lattice.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lx</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">Ly</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">periodic_x</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">periodic_y</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "src.hilbert.lattice.Lx", "modulename": "src.hilbert", "qualname": "lattice.Lx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.lattice.Ly", "modulename": "src.hilbert", "qualname": "lattice.Ly", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.lattice.periodic_x", "modulename": "src.hilbert", "qualname": "lattice.periodic_x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.lattice.periodic_y", "modulename": "src.hilbert", "qualname": "lattice.periodic_y", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.lattice.links", "modulename": "src.hilbert", "qualname": "lattice.links", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.lattice.ylinks", "modulename": "src.hilbert", "qualname": "lattice.ylinks", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.space", "modulename": "src.hilbert", "qualname": "space", "kind": "class", "doc": "<p>Contains all the vectors in Hilbert space, as well as matrtices for observables.\\\nThis is only useful for full summation algorithms.</p>\n\n<h2 id=\"variables\">Variables</h2>\n\n<ul>\n<li><code>lat</code>: lattice object (contains lattice dimensions and bond index pairs)</li>\n<li><code>model</code>: which Hamiltonian to use? choose: <code>'heisenberg'</code>, <code>'ising'</code></li>\n<li><code>driving</code>: which model should you use for the driving? choose:\n&gt; <code>'light'</code>: perturbation of y-bonds,\\\n&gt; <code>'JQ'</code>: perturbation by turning on the dimer terms on all 4-point plaquettes,\\\n&gt; <code>'J1J2'</code>: perturbation by turning on the diagonal terms,\\\n&gt; <code>'TF'</code>: transverse (x) field perturbation.\\\n&gt; <strong>NOTE</strong>: Be careful not set one-dimensional lattices for diagonal and dimer interactions.</li>\n<li><code>afm</code>: bool for deciding if it's an antiferromagnet</li>\n</ul>\n\n<h2 id=\"properties\">Properties</h2>\n\n<ul>\n<li><code>dim</code>: dimension of the used part of the Hilbert (sub)space</li>\n<li><code>configs</code>: configurations of the used Hilbert (sub)space</li>\n<li><code>H</code>: the Hamiltonian</li>\n<li><code>correlations</code>, <code>zcorrelations</code>: a <code>link -&gt; matrix</code> dictionary of (z) correlations at the link</li>\n</ul>\n"}, {"fullname": "src.hilbert.space.__init__", "modulename": "src.hilbert", "qualname": "space.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">lat</span><span class=\"p\">:</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">hilbert</span><span class=\"o\">.</span><span class=\"n\">lattice</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;heisenberg&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">driving</span><span class=\"o\">=</span><span class=\"s1\">&#39;light&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">afm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">gauge</span><span class=\"o\">=</span><span class=\"kc\">True</span></span>)</span>"}, {"fullname": "src.hilbert.space.grid", "modulename": "src.hilbert", "qualname": "space.grid", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.space.N", "modulename": "src.hilbert", "qualname": "space.N", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.space.model", "modulename": "src.hilbert", "qualname": "space.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.space.driving", "modulename": "src.hilbert", "qualname": "space.driving", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.space.afm", "modulename": "src.hilbert", "qualname": "space.afm", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.space.gauge", "modulename": "src.hilbert", "qualname": "space.gauge", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.hilbert.space.make_dimers", "modulename": "src.hilbert", "qualname": "space.make_dimers", "kind": "function", "doc": "<p>Creates a matrix of dimer interactions on all the plaquettes of the lattice.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.space.make_transverse", "modulename": "src.hilbert", "qualname": "space.make_transverse", "kind": "function", "doc": "<p>Creates a matrix of all single pauli x-matrices.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.space.perturb", "modulename": "src.hilbert", "qualname": "space.perturb", "kind": "function", "doc": "<p>Pertubs the Hamiltonian with the prescribed perturbation protocol with the some <code>perturbation</code> strength.\\\nFor more information, see <code>model</code> and <code>driving</code> properties of the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">perturbation</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.hilbert.space.make_correlation", "modulename": "src.hilbert", "qualname": "space.make_correlation", "kind": "function", "doc": "<p>Makes the matrix for full- and z-correlation between the selected <code>pair</code> of lattice indices. The pair does not need to be linked by lattice goemetry.\\\nProjects them into the Hilbert subspace (antiferromagnet).</p>\n\n<p>Appends them into the correlation dictionaries.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pair</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm", "modulename": "src.rbm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "src.rbm.bias_map", "modulename": "src.rbm", "qualname": "bias_map", "kind": "function", "doc": "<p>Generates an array that maps the indices of independent biases onto the full set of biases.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">alpha</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm.split_and_roll", "modulename": "src.rbm", "qualname": "split_and_roll", "kind": "function", "doc": "<p>Splits the <code>array</code> into <code>Lx</code> parts and rolls each part backwards once. This accounts for translational invariance over the X-direction.\\\nReturns the fully connected array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">Lx</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm.generate_block", "modulename": "src.rbm", "qualname": "generate_block", "kind": "function", "doc": "<p>Takes an input <code>array</code> and repeats it <code>Ly</code> times to create a matrix. Each time it's repeated, all <code>Lx</code> of it's parts are rolled backwards once. This accounts, in total, for the translational invariance in the Y-direction.\\\nReturns the created matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Ly</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm.roll_and_concatenate", "modulename": "src.rbm", "qualname": "roll_and_concatenate", "kind": "function", "doc": "<p>Takes an array and:</p>\n\n<ol>\n<li>performs block generation to account for translational invariance in both X- and Y-directions,</li>\n<li>repeats the process <code>Lx</code> times in total to finalize the X-direction invariance,</li>\n<li>after each repetition, the entire block is rolled backwards <code>Ly</code> times, to finalize the Y-direction invariance.</li>\n</ol>\n\n<p>Returns the final amalgam of blocks.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Ly</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm.weight_map", "modulename": "src.rbm", "qualname": "weight_map", "kind": "function", "doc": "<p>Generates an index matrix that maps the independent weights to the full set of weights.</p>\n\n<p>Independent weights are shaped as a vector.\nThe shape of the index matrix is the same as the shape of the full weight matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lx</span>, </span><span class=\"param\"><span class=\"n\">Ly</span>, </span><span class=\"param\"><span class=\"n\">alpha</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm.sum_weigth_derivatives", "modulename": "src.rbm", "qualname": "sum_weigth_derivatives", "kind": "function", "doc": "<p>Sums over the outer product of the lookup table and spins, or matrix <code>A</code>, to get the proper derivatives by weights.\nSupossedly optimized to exploit numpy to the max, says ChatGPT.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm.rbm_parameters", "modulename": "src.rbm", "qualname": "rbm_parameters", "kind": "class", "doc": "<p>A structure for keeping weights and biases.</p>\n\n<p>-<code>b_number</code>: number of biases, or hidden layer nodes.\n-<code>w_shape</code>: shape of the weight matrix, or connections between the visible and the hidden layers.</p>\n\n<ul>\n<li><code>real</code>: do you want to initialize them as real?</li>\n</ul>\n\n<p>Biases and weights must be flattened and concatenated into a single vector.</p>\n"}, {"fullname": "src.rbm.rbm_parameters.__init__", "modulename": "src.rbm", "qualname": "rbm_parameters.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_number</span>, </span><span class=\"param\"><span class=\"n\">w_shape</span>, </span><span class=\"param\"><span class=\"n\">real</span><span class=\"o\">=</span><span class=\"kc\">True</span></span>)</span>"}, {"fullname": "src.rbm.rbm_parameters.b", "modulename": "src.rbm", "qualname": "rbm_parameters.b", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm_parameters.w", "modulename": "src.rbm", "qualname": "rbm_parameters.w", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm_parameters.all", "modulename": "src.rbm", "qualname": "rbm_parameters.all", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm", "modulename": "src.rbm", "qualname": "rbm", "kind": "class", "doc": "<p>Properties and method for manipulating the Restricted Boltzmann Machine neural network.\\\nInitialized from the number of physical spins and the network density.</p>\n\n<h2 id=\"variables\">Variables</h2>\n\n<ul>\n<li><code>Lx</code>, <code>Ly</code>: lattice dimensions</li>\n<li><code>alpha</code>: network density </li>\n<li><code>tinv</code>: is the network translationally invariant? this changes the number of used parameters</li>\n</ul>\n\n<h2 id=\"properties\">Properties</h2>\n\n<ul>\n<li><code>N</code>: number of visible spins (neurons)</li>\n<li><code>M</code>: number of hidden neurons <code>M</code>=<code>alpha</code>*<code>N</code></li>\n<li><code>parameters</code>: set of network weights and biases</li>\n<li><code>real</code>: do you want to initialize parameters as real?</li>\n<li><code>scale</code>: scale the wave function with this number</li>\n</ul>\n\n<h2 id=\"methods\">Methods</h2>\n\n<ul>\n<li><code>logpsi(spins)</code>: logarithmic wave function</li>\n<li><code>vecpsi(spins)</code>: Hilbert space vector of the wave function</li>\n<li><code>Ok(spins)</code>: rbm-parameter-like structure of derivatives by parameters</li>\n</ul>\n\n<p>NOTE: spin vector should be flattened and properly labeled.</p>\n"}, {"fullname": "src.rbm.rbm.__init__", "modulename": "src.rbm", "qualname": "rbm.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Lx</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">Ly</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">alpha</span>, </span><span class=\"param\"><span class=\"n\">tinv</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">real</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span>)</span>"}, {"fullname": "src.rbm.rbm.alpha", "modulename": "src.rbm", "qualname": "rbm.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm.N", "modulename": "src.rbm", "qualname": "rbm.N", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm.M", "modulename": "src.rbm", "qualname": "rbm.M", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm.scale", "modulename": "src.rbm", "qualname": "rbm.scale", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm.tinv", "modulename": "src.rbm", "qualname": "rbm.tinv", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm.parameters", "modulename": "src.rbm", "qualname": "rbm.parameters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "src.rbm.rbm.logpsi", "modulename": "src.rbm", "qualname": "rbm.logpsi", "kind": "function", "doc": "<p>Calculates the wave function (network output) for a spin configuration.</p>\n\n<ul>\n<li><code>spins</code>: array containing all spin values.</li>\n</ul>\n\n<p>Returns the logarithm of the wavefunction - more numerically stable.\nHas to be exponentiated when calculating observables or output vectors.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spins</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm.rbm.vecpsi", "modulename": "src.rbm", "qualname": "rbm.vecpsi", "kind": "function", "doc": "<p>Calculates the vector in the Hilbert space from the wave function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">configurations</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "src.rbm.rbm.Ok", "modulename": "src.rbm", "qualname": "rbm.Ok", "kind": "function", "doc": "<p>Calculates the logarithmic derivative vector by biases and weights.\n-<code>spins</code>: spin configuration</p>\n\n<p>Returns a structure in the same shape as RBM parameters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spins</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();